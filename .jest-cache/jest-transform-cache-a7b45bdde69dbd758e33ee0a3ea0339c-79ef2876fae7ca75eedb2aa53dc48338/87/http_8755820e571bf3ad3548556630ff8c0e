586bda155c115e44542bf9ea5a88bc3b
const axios = require('axios');
const http = require('http');
const https = require('https');
const config = require('../config');
const httpAgent = new http.Agent({
  keepAlive: true
});
const httpsAgent = new https.Agent({
  keepAlive: true
});
const wpClient = axios.create({
  baseURL: config.wordpress.url,
  timeout: 15000,
  // 15 seconds default timeout
  httpAgent,
  httpsAgent,
  headers: {
    'Content-Type': 'application/json'
  }
});

// Mock Adapter Implementation
if (process.env.USE_MOCKS === 'true') {
  const fs = require('fs');
  const path = require('path');
  console.log('⚠️  USING MOCKS FOR EXTERNAL HTTP CALLS ⚠️');
  wpClient.defaults.adapter = async config => {
    return new Promise((resolve, reject) => {
      const url = config.url || '';
      let mockFile = '';

      // Generic Router
      // Improved Regex to handle nested resources like 'products/categories' or 'reports/sales'.
      // Strategy: Check specifically for known nested patterns first, or use a more greedy match.
      // But 'products/123' vs 'products/categories' is ambiguous without knowledge.
      // Let's hardcode known nested valid endpoints for this project as exceptions, or check directory existence.

      // Simple approach: Capture up to 2 segments after version.
      const regex = /^\/?(?:(wc)\/v3|(ldlms)\/v2|(wp)\/v2)\/(.+)/;
      const match = url.match(regex);
      if (match) {
        const ns = match[1] || match[2] || match[3]; // wc, ldlms, wp
        const pathSuffix = match[4].split('?')[0]; // e.g. "products/categories", "products/123" (strip query)

        // We need to decide what part is 'resource' and what is 'id'.
        // Heuristic:
        // 1. Check if full path maps to a directory -> It's a list (resource=full path).
        // 2. Else, split last segment as ID, rest as resource.

        const folderNs = ns === 'ldlms' ? 'ld' : ns;
        const rootMockDir = path.resolve(process.cwd(), `mocks/wordpress/${folderNs}`);
        const possibleDir = path.join(rootMockDir, pathSuffix);
        let resource, id;
        if (fs.existsSync(possibleDir) && fs.lstatSync(possibleDir).isDirectory()) {
          // It is a directory (e.g. products/categories, or products)
          resource = pathSuffix;
          id = null;
        } else {
          // It is not a directory. Assume last part is ID.
          const parts = pathSuffix.split('/');
          if (parts.length > 1) {
            id = parts.pop();
            resource = parts.join('/');
          } else {
            // Should have been a directory if it was a list root... 
            // But maybe directory is missing?
            resource = pathSuffix;
            id = null;
          }
        }
        const baseDir = path.join(rootMockDir, resource);
        if (id) {
          // Try specific ID
          const specific = path.join(baseDir, `${id}.json`);
          const def = path.join(baseDir, 'default.json');
          if (fs.existsSync(specific)) {
            mockFile = specific;
          } else if (fs.existsSync(def)) {
            mockFile = def;
          } else {
            // Fallback: Check if list exists, maybe? No, usually ID call expects object.
            // If really nothing found, we let fall through to 404
          }
        } else {
          // List
          const list = path.join(baseDir, 'list.json');
          if (fs.existsSync(list)) {
            mockFile = list;
          }
          // Some endpoints like singletons (users-course-progress) might behave like "default" without ID?
          // Check if there is a 'default.json' for the resource root? 
          // e.g. users-course-progress_v2/default.json
          const rootDefault = path.join(baseDir, 'default.json');
          if (!mockFile && fs.existsSync(rootDefault)) {
            mockFile = rootDefault;
          }
        }
      } else {
        console.log(`[MOCK] URL ${url} did not match supported patterns.`);
      }
      if (mockFile && fs.existsSync(mockFile)) {
        try {
          const data = JSON.parse(fs.readFileSync(mockFile, 'utf8'));
          console.log(`[MOCK] Serving ${mockFile} for ${url}`);
          resolve({
            data,
            status: 200,
            statusText: 'OK',
            headers: {},
            config,
            request: {}
          });
        } catch (e) {
          reject({
            message: 'Failed to parse mock file',
            config,
            response: {
              status: 500
            }
          });
        }
      } else {
        console.log(`[MOCK] No mock found for ${url}, returning 404`);
        // Simulate 404 for unknown mocks
        reject({
          message: 'Request failed with status code 404',
          name: 'AxiosError',
          code: 'ERR_BAD_REQUEST',
          config,
          response: {
            status: 404,
            statusText: 'Not Found',
            data: {
              code: 'rest_no_route',
              message: 'No route was found matching the URL and request method',
              data: {
                status: 404
              }
            }
          }
        });
      }
    });
  };
}

// Helper for Basic Auth (WooCommerce)
const getWcAuthHeader = () => {
  const auth = Buffer.from(`${config.wordpress.wcConsumerKey}:${config.wordpress.wcConsumerSecret}`).toString('base64');
  return `Basic ${auth}`;
};

// Helper for Application Password (LearnDash)
const getLdAuthHeader = () => {
  const auth = Buffer.from(`${config.wordpress.ldUser}:${config.wordpress.ldAppPassword}`).toString('base64');
  return `Basic ${auth}`;
};
module.exports = {
  wpClient,
  getWcAuthHeader,
  getLdAuthHeader
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJheGlvcyIsInJlcXVpcmUiLCJodHRwIiwiaHR0cHMiLCJjb25maWciLCJodHRwQWdlbnQiLCJBZ2VudCIsImtlZXBBbGl2ZSIsImh0dHBzQWdlbnQiLCJ3cENsaWVudCIsImNyZWF0ZSIsImJhc2VVUkwiLCJ3b3JkcHJlc3MiLCJ1cmwiLCJ0aW1lb3V0IiwiaGVhZGVycyIsInByb2Nlc3MiLCJlbnYiLCJVU0VfTU9DS1MiLCJmcyIsInBhdGgiLCJjb25zb2xlIiwibG9nIiwiZGVmYXVsdHMiLCJhZGFwdGVyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJtb2NrRmlsZSIsInJlZ2V4IiwibWF0Y2giLCJucyIsInBhdGhTdWZmaXgiLCJzcGxpdCIsImZvbGRlck5zIiwicm9vdE1vY2tEaXIiLCJjd2QiLCJwb3NzaWJsZURpciIsImpvaW4iLCJyZXNvdXJjZSIsImlkIiwiZXhpc3RzU3luYyIsImxzdGF0U3luYyIsImlzRGlyZWN0b3J5IiwicGFydHMiLCJsZW5ndGgiLCJwb3AiLCJiYXNlRGlyIiwic3BlY2lmaWMiLCJkZWYiLCJsaXN0Iiwicm9vdERlZmF1bHQiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwicmVhZEZpbGVTeW5jIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsInJlcXVlc3QiLCJlIiwibWVzc2FnZSIsInJlc3BvbnNlIiwibmFtZSIsImNvZGUiLCJnZXRXY0F1dGhIZWFkZXIiLCJhdXRoIiwiQnVmZmVyIiwiZnJvbSIsIndjQ29uc3VtZXJLZXkiLCJ3Y0NvbnN1bWVyU2VjcmV0IiwidG9TdHJpbmciLCJnZXRMZEF1dGhIZWFkZXIiLCJsZFVzZXIiLCJsZEFwcFBhc3N3b3JkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VzIjpbImh0dHAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYXhpb3MgPSByZXF1aXJlKCdheGlvcycpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG5jb25zdCBodHRwQWdlbnQgPSBuZXcgaHR0cC5BZ2VudCh7IGtlZXBBbGl2ZTogdHJ1ZSB9KTtcbmNvbnN0IGh0dHBzQWdlbnQgPSBuZXcgaHR0cHMuQWdlbnQoeyBrZWVwQWxpdmU6IHRydWUgfSk7XG5cbmNvbnN0IHdwQ2xpZW50ID0gYXhpb3MuY3JlYXRlKHtcbiAgICBiYXNlVVJMOiBjb25maWcud29yZHByZXNzLnVybCxcbiAgICB0aW1lb3V0OiAxNTAwMCwgLy8gMTUgc2Vjb25kcyBkZWZhdWx0IHRpbWVvdXRcbiAgICBodHRwQWdlbnQsXG4gICAgaHR0cHNBZ2VudCxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgfSxcbn0pO1xuXG4vLyBNb2NrIEFkYXB0ZXIgSW1wbGVtZW50YXRpb25cbmlmIChwcm9jZXNzLmVudi5VU0VfTU9DS1MgPT09ICd0cnVlJykge1xuICAgIGNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICBjb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuICAgIGNvbnNvbGUubG9nKCfimqDvuI8gIFVTSU5HIE1PQ0tTIEZPUiBFWFRFUk5BTCBIVFRQIENBTExTIOKaoO+4jycpO1xuXG4gICAgd3BDbGllbnQuZGVmYXVsdHMuYWRhcHRlciA9IGFzeW5jIChjb25maWcpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGNvbmZpZy51cmwgfHwgJyc7XG4gICAgICAgICAgICBsZXQgbW9ja0ZpbGUgPSAnJztcblxuICAgICAgICAgICAgLy8gR2VuZXJpYyBSb3V0ZXJcbiAgICAgICAgICAgIC8vIEltcHJvdmVkIFJlZ2V4IHRvIGhhbmRsZSBuZXN0ZWQgcmVzb3VyY2VzIGxpa2UgJ3Byb2R1Y3RzL2NhdGVnb3JpZXMnIG9yICdyZXBvcnRzL3NhbGVzJy5cbiAgICAgICAgICAgIC8vIFN0cmF0ZWd5OiBDaGVjayBzcGVjaWZpY2FsbHkgZm9yIGtub3duIG5lc3RlZCBwYXR0ZXJucyBmaXJzdCwgb3IgdXNlIGEgbW9yZSBncmVlZHkgbWF0Y2guXG4gICAgICAgICAgICAvLyBCdXQgJ3Byb2R1Y3RzLzEyMycgdnMgJ3Byb2R1Y3RzL2NhdGVnb3JpZXMnIGlzIGFtYmlndW91cyB3aXRob3V0IGtub3dsZWRnZS5cbiAgICAgICAgICAgIC8vIExldCdzIGhhcmRjb2RlIGtub3duIG5lc3RlZCB2YWxpZCBlbmRwb2ludHMgZm9yIHRoaXMgcHJvamVjdCBhcyBleGNlcHRpb25zLCBvciBjaGVjayBkaXJlY3RvcnkgZXhpc3RlbmNlLlxuXG4gICAgICAgICAgICAvLyBTaW1wbGUgYXBwcm9hY2g6IENhcHR1cmUgdXAgdG8gMiBzZWdtZW50cyBhZnRlciB2ZXJzaW9uLlxuICAgICAgICAgICAgY29uc3QgcmVnZXggPSAvXlxcLz8oPzood2MpXFwvdjN8KGxkbG1zKVxcL3YyfCh3cClcXC92MilcXC8oLispLztcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdXJsLm1hdGNoKHJlZ2V4KTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbnMgPSBtYXRjaFsxXSB8fCBtYXRjaFsyXSB8fCBtYXRjaFszXTsgLy8gd2MsIGxkbG1zLCB3cFxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhTdWZmaXggPSBtYXRjaFs0XS5zcGxpdCgnPycpWzBdOyAvLyBlLmcuIFwicHJvZHVjdHMvY2F0ZWdvcmllc1wiLCBcInByb2R1Y3RzLzEyM1wiIChzdHJpcCBxdWVyeSlcblxuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZGVjaWRlIHdoYXQgcGFydCBpcyAncmVzb3VyY2UnIGFuZCB3aGF0IGlzICdpZCcuXG4gICAgICAgICAgICAgICAgLy8gSGV1cmlzdGljOlxuICAgICAgICAgICAgICAgIC8vIDEuIENoZWNrIGlmIGZ1bGwgcGF0aCBtYXBzIHRvIGEgZGlyZWN0b3J5IC0+IEl0J3MgYSBsaXN0IChyZXNvdXJjZT1mdWxsIHBhdGgpLlxuICAgICAgICAgICAgICAgIC8vIDIuIEVsc2UsIHNwbGl0IGxhc3Qgc2VnbWVudCBhcyBJRCwgcmVzdCBhcyByZXNvdXJjZS5cblxuICAgICAgICAgICAgICAgIGNvbnN0IGZvbGRlck5zID0gbnMgPT09ICdsZGxtcycgPyAnbGQnIDogbnM7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vdE1vY2tEaXIgPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgYG1vY2tzL3dvcmRwcmVzcy8ke2ZvbGRlck5zfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlRGlyID0gcGF0aC5qb2luKHJvb3RNb2NrRGlyLCBwYXRoU3VmZml4KTtcblxuICAgICAgICAgICAgICAgIGxldCByZXNvdXJjZSwgaWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhwb3NzaWJsZURpcikgJiYgZnMubHN0YXRTeW5jKHBvc3NpYmxlRGlyKS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEl0IGlzIGEgZGlyZWN0b3J5IChlLmcuIHByb2R1Y3RzL2NhdGVnb3JpZXMsIG9yIHByb2R1Y3RzKVxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZSA9IHBhdGhTdWZmaXg7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJdCBpcyBub3QgYSBkaXJlY3RvcnkuIEFzc3VtZSBsYXN0IHBhcnQgaXMgSUQuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gcGF0aFN1ZmZpeC5zcGxpdCgnLycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBwYXJ0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlID0gcGFydHMuam9pbignLycpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIGhhdmUgYmVlbiBhIGRpcmVjdG9yeSBpZiBpdCB3YXMgYSBsaXN0IHJvb3QuLi4gXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCdXQgbWF5YmUgZGlyZWN0b3J5IGlzIG1pc3Npbmc/XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZSA9IHBhdGhTdWZmaXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlRGlyID0gcGF0aC5qb2luKHJvb3RNb2NrRGlyLCByZXNvdXJjZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHNwZWNpZmljIElEXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwZWNpZmljID0gcGF0aC5qb2luKGJhc2VEaXIsIGAke2lkfS5qc29uYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZiA9IHBhdGguam9pbihiYXNlRGlyLCAnZGVmYXVsdC5qc29uJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoc3BlY2lmaWMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2NrRmlsZSA9IHNwZWNpZmljO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZzLmV4aXN0c1N5bmMoZGVmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9ja0ZpbGUgPSBkZWY7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjazogQ2hlY2sgaWYgbGlzdCBleGlzdHMsIG1heWJlPyBObywgdXN1YWxseSBJRCBjYWxsIGV4cGVjdHMgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgcmVhbGx5IG5vdGhpbmcgZm91bmQsIHdlIGxldCBmYWxsIHRocm91Z2ggdG8gNDA0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBMaXN0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpc3QgPSBwYXRoLmpvaW4oYmFzZURpciwgJ2xpc3QuanNvbicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhsaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9ja0ZpbGUgPSBsaXN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFNvbWUgZW5kcG9pbnRzIGxpa2Ugc2luZ2xldG9ucyAodXNlcnMtY291cnNlLXByb2dyZXNzKSBtaWdodCBiZWhhdmUgbGlrZSBcImRlZmF1bHRcIiB3aXRob3V0IElEP1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSBpcyBhICdkZWZhdWx0Lmpzb24nIGZvciB0aGUgcmVzb3VyY2Ugcm9vdD8gXG4gICAgICAgICAgICAgICAgICAgIC8vIGUuZy4gdXNlcnMtY291cnNlLXByb2dyZXNzX3YyL2RlZmF1bHQuanNvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCByb290RGVmYXVsdCA9IHBhdGguam9pbihiYXNlRGlyLCAnZGVmYXVsdC5qc29uJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbW9ja0ZpbGUgJiYgZnMuZXhpc3RzU3luYyhyb290RGVmYXVsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vY2tGaWxlID0gcm9vdERlZmF1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbTU9DS10gVVJMICR7dXJsfSBkaWQgbm90IG1hdGNoIHN1cHBvcnRlZCBwYXR0ZXJucy5gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1vY2tGaWxlICYmIGZzLmV4aXN0c1N5bmMobW9ja0ZpbGUpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKG1vY2tGaWxlLCAndXRmOCcpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtNT0NLXSBTZXJ2aW5nICR7bW9ja0ZpbGV9IGZvciAke3VybH1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiB7fVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh7IG1lc3NhZ2U6ICdGYWlsZWQgdG8gcGFyc2UgbW9jayBmaWxlJywgY29uZmlnLCByZXNwb25zZTogeyBzdGF0dXM6IDUwMCB9IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtNT0NLXSBObyBtb2NrIGZvdW5kIGZvciAke3VybH0sIHJldHVybmluZyA0MDRgKTtcbiAgICAgICAgICAgICAgICAvLyBTaW11bGF0ZSA0MDQgZm9yIHVua25vd24gbW9ja3NcbiAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSA0MDQnLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXhpb3NFcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJfQkFEX1JFUVVFU1QnLFxuICAgICAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDQwNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6ICdOb3QgRm91bmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogeyBjb2RlOiAncmVzdF9ub19yb3V0ZScsIG1lc3NhZ2U6ICdObyByb3V0ZSB3YXMgZm91bmQgbWF0Y2hpbmcgdGhlIFVSTCBhbmQgcmVxdWVzdCBtZXRob2QnLCBkYXRhOiB7IHN0YXR1czogNDA0IH0gfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbi8vIEhlbHBlciBmb3IgQmFzaWMgQXV0aCAoV29vQ29tbWVyY2UpXG5jb25zdCBnZXRXY0F1dGhIZWFkZXIgPSAoKSA9PiB7XG4gICAgY29uc3QgYXV0aCA9IEJ1ZmZlci5mcm9tKGAke2NvbmZpZy53b3JkcHJlc3Mud2NDb25zdW1lcktleX06JHtjb25maWcud29yZHByZXNzLndjQ29uc3VtZXJTZWNyZXR9YCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIHJldHVybiBgQmFzaWMgJHthdXRofWA7XG59O1xuXG4vLyBIZWxwZXIgZm9yIEFwcGxpY2F0aW9uIFBhc3N3b3JkIChMZWFybkRhc2gpXG5jb25zdCBnZXRMZEF1dGhIZWFkZXIgPSAoKSA9PiB7XG4gICAgY29uc3QgYXV0aCA9IEJ1ZmZlci5mcm9tKGAke2NvbmZpZy53b3JkcHJlc3MubGRVc2VyfToke2NvbmZpZy53b3JkcHJlc3MubGRBcHBQYXNzd29yZH1gKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgcmV0dXJuIGBCYXNpYyAke2F1dGh9YDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHdwQ2xpZW50LFxuICAgIGdldFdjQXV0aEhlYWRlcixcbiAgICBnZXRMZEF1dGhIZWFkZXJcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLEtBQUssR0FBR0MsT0FBTyxDQUFDLE9BQU8sQ0FBQztBQUM5QixNQUFNQyxJQUFJLEdBQUdELE9BQU8sQ0FBQyxNQUFNLENBQUM7QUFDNUIsTUFBTUUsS0FBSyxHQUFHRixPQUFPLENBQUMsT0FBTyxDQUFDO0FBQzlCLE1BQU1HLE1BQU0sR0FBR0gsT0FBTyxDQUFDLFdBQVcsQ0FBQztBQUVuQyxNQUFNSSxTQUFTLEdBQUcsSUFBSUgsSUFBSSxDQUFDSSxLQUFLLENBQUM7RUFBRUMsU0FBUyxFQUFFO0FBQUssQ0FBQyxDQUFDO0FBQ3JELE1BQU1DLFVBQVUsR0FBRyxJQUFJTCxLQUFLLENBQUNHLEtBQUssQ0FBQztFQUFFQyxTQUFTLEVBQUU7QUFBSyxDQUFDLENBQUM7QUFFdkQsTUFBTUUsUUFBUSxHQUFHVCxLQUFLLENBQUNVLE1BQU0sQ0FBQztFQUMxQkMsT0FBTyxFQUFFUCxNQUFNLENBQUNRLFNBQVMsQ0FBQ0MsR0FBRztFQUM3QkMsT0FBTyxFQUFFLEtBQUs7RUFBRTtFQUNoQlQsU0FBUztFQUNURyxVQUFVO0VBQ1ZPLE9BQU8sRUFBRTtJQUNMLGNBQWMsRUFBRTtFQUNwQjtBQUNKLENBQUMsQ0FBQzs7QUFFRjtBQUNBLElBQUlDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDQyxTQUFTLEtBQUssTUFBTSxFQUFFO0VBQ2xDLE1BQU1DLEVBQUUsR0FB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