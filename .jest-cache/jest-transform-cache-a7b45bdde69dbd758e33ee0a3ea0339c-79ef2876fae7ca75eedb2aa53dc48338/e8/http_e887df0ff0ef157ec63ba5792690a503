19b81998bba641c4f411c51e703d7f41
const axios = require('axios');
const http = require('http');
const https = require('https');
const config = require('../config');
const httpAgent = new http.Agent({
  keepAlive: true
});
const httpsAgent = new https.Agent({
  keepAlive: true
});
const wpClient = axios.create({
  baseURL: config.wordpress.url,
  timeout: 15000,
  // 15 seconds default timeout
  httpAgent,
  httpsAgent,
  headers: {
    'Content-Type': 'application/json'
  }
});

// Mock Adapter Implementation
if (process.env.USE_MOCKS === 'true') {
  const fs = require('fs');
  const path = require('path');
  console.log('⚠️  USING MOCKS FOR EXTERNAL HTTP CALLS ⚠️');
  wpClient.defaults.adapter = async config => {
    return new Promise((resolve, reject) => {
      const url = config.url || '';
      let mockFile = '';

      // Generic Router
      // Improved Regex to handle nested resources like 'products/categories' or 'reports/sales'.
      // Strategy: Check specifically for known nested patterns first, or use a more greedy match.
      // But 'products/123' vs 'products/categories' is ambiguous without knowledge.
      // Let's hardcode known nested valid endpoints for this project as exceptions, or check directory existence.

      // Simple approach: Capture up to 2 segments after version.
      const regex = /^\/?(?:(wc)\/v3|(ldlms)\/v2|(wp)\/v2)\/(.+)/;
      const match = url.match(regex);
      if (match) {
        const ns = match[1] || match[2] || match[3]; // wc, ldlms, wp
        const pathSuffix = match[4]; // e.g. "products/categories", "products/123", "orders"

        // We need to decide what part is 'resource' and what is 'id'.
        // Heuristic:
        // 1. Check if full path maps to a directory -> It's a list (resource=full path).
        // 2. Else, split last segment as ID, rest as resource.

        const folderNs = ns === 'ldlms' ? 'ld' : ns;
        const rootMockDir = path.resolve(process.cwd(), `mocks/wordpress/${folderNs}`);
        const possibleDir = path.join(rootMockDir, pathSuffix);
        let resource, id;
        if (fs.existsSync(possibleDir) && fs.lstatSync(possibleDir).isDirectory()) {
          // It is a directory (e.g. products/categories, or products)
          resource = pathSuffix;
          id = null;
        } else {
          // It is not a directory. Assume last part is ID.
          const parts = pathSuffix.split('/');
          if (parts.length > 1) {
            id = parts.pop();
            resource = parts.join('/');
          } else {
            // Should have been a directory if it was a list root... 
            // But maybe directory is missing?
            resource = pathSuffix;
            id = null;
          }
        }
        const baseDir = path.join(rootMockDir, resource);
        if (id) {
          // Try specific ID
          const specific = path.join(baseDir, `${id}.json`);
          const def = path.join(baseDir, 'default.json');
          if (fs.existsSync(specific)) {
            mockFile = specific;
          } else if (fs.existsSync(def)) {
            mockFile = def;
          } else {
            // Fallback: Check if list exists, maybe? No, usually ID call expects object.
            // If really nothing found, we let fall through to 404
          }
        } else {
          // List
          const list = path.join(baseDir, 'list.json');
          if (fs.existsSync(list)) {
            mockFile = list;
          }
          // Some endpoints like singletons (users-course-progress) might behave like "default" without ID?
          // Check if there is a 'default.json' for the resource root? 
          // e.g. users-course-progress_v2/default.json
          const rootDefault = path.join(baseDir, 'default.json');
          if (!mockFile && fs.existsSync(rootDefault)) {
            mockFile = rootDefault;
          }
        }
      } else {
        console.log(`[MOCK] URL ${url} did not match supported patterns.`);
      }
      if (mockFile && fs.existsSync(mockFile)) {
        try {
          const data = JSON.parse(fs.readFileSync(mockFile, 'utf8'));
          console.log(`[MOCK] Serving ${mockFile} for ${url}`);
          resolve({
            data,
            status: 200,
            statusText: 'OK',
            headers: {},
            config,
            request: {}
          });
        } catch (e) {
          reject({
            message: 'Failed to parse mock file',
            config,
            response: {
              status: 500
            }
          });
        }
      } else {
        console.log(`[MOCK] No mock found for ${url}, returning 404`);
        // Simulate 404 for unknown mocks
        reject({
          message: 'Request failed with status code 404',
          name: 'AxiosError',
          code: 'ERR_BAD_REQUEST',
          config,
          response: {
            status: 404,
            statusText: 'Not Found',
            data: {
              code: 'rest_no_route',
              message: 'No route was found matching the URL and request method',
              data: {
                status: 404
              }
            }
          }
        });
      }
    });
  };
}

// Helper for Basic Auth (WooCommerce)
const getWcAuthHeader = () => {
  const auth = Buffer.from(`${config.wordpress.wcConsumerKey}:${config.wordpress.wcConsumerSecret}`).toString('base64');
  return `Basic ${auth}`;
};

// Helper for Application Password (LearnDash)
const getLdAuthHeader = () => {
  const auth = Buffer.from(`${config.wordpress.ldUser}:${config.wordpress.ldAppPassword}`).toString('base64');
  return `Basic ${auth}`;
};
module.exports = {
  wpClient,
  getWcAuthHeader,
  getLdAuthHeader
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJheGlvcyIsInJlcXVpcmUiLCJodHRwIiwiaHR0cHMiLCJjb25maWciLCJodHRwQWdlbnQiLCJBZ2VudCIsImtlZXBBbGl2ZSIsImh0dHBzQWdlbnQiLCJ3cENsaWVudCIsImNyZWF0ZSIsImJhc2VVUkwiLCJ3b3JkcHJlc3MiLCJ1cmwiLCJ0aW1lb3V0IiwiaGVhZGVycyIsInByb2Nlc3MiLCJlbnYiLCJVU0VfTU9DS1MiLCJmcyIsInBhdGgiLCJjb25zb2xlIiwibG9nIiwiZGVmYXVsdHMiLCJhZGFwdGVyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJtb2NrRmlsZSIsInJlZ2V4IiwibWF0Y2giLCJucyIsInBhdGhTdWZmaXgiLCJmb2xkZXJOcyIsInJvb3RNb2NrRGlyIiwiY3dkIiwicG9zc2libGVEaXIiLCJqb2luIiwicmVzb3VyY2UiLCJpZCIsImV4aXN0c1N5bmMiLCJsc3RhdFN5bmMiLCJpc0RpcmVjdG9yeSIsInBhcnRzIiwic3BsaXQiLCJsZW5ndGgiLCJwb3AiLCJiYXNlRGlyIiwic3BlY2lmaWMiLCJkZWYiLCJsaXN0Iiwicm9vdERlZmF1bHQiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwicmVhZEZpbGVTeW5jIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsInJlcXVlc3QiLCJlIiwibWVzc2FnZSIsInJlc3BvbnNlIiwibmFtZSIsImNvZGUiLCJnZXRXY0F1dGhIZWFkZXIiLCJhdXRoIiwiQnVmZmVyIiwiZnJvbSIsIndjQ29uc3VtZXJLZXkiLCJ3Y0NvbnN1bWVyU2VjcmV0IiwidG9TdHJpbmciLCJnZXRMZEF1dGhIZWFkZXIiLCJsZFVzZXIiLCJsZEFwcFBhc3N3b3JkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VzIjpbImh0dHAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYXhpb3MgPSByZXF1aXJlKCdheGlvcycpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG5jb25zdCBodHRwQWdlbnQgPSBuZXcgaHR0cC5BZ2VudCh7IGtlZXBBbGl2ZTogdHJ1ZSB9KTtcbmNvbnN0IGh0dHBzQWdlbnQgPSBuZXcgaHR0cHMuQWdlbnQoeyBrZWVwQWxpdmU6IHRydWUgfSk7XG5cbmNvbnN0IHdwQ2xpZW50ID0gYXhpb3MuY3JlYXRlKHtcbiAgICBiYXNlVVJMOiBjb25maWcud29yZHByZXNzLnVybCxcbiAgICB0aW1lb3V0OiAxNTAwMCwgLy8gMTUgc2Vjb25kcyBkZWZhdWx0IHRpbWVvdXRcbiAgICBodHRwQWdlbnQsXG4gICAgaHR0cHNBZ2VudCxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgfSxcbn0pO1xuXG4vLyBNb2NrIEFkYXB0ZXIgSW1wbGVtZW50YXRpb25cbmlmIChwcm9jZXNzLmVudi5VU0VfTU9DS1MgPT09ICd0cnVlJykge1xuICAgIGNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICBjb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuICAgIGNvbnNvbGUubG9nKCfimqDvuI8gIFVTSU5HIE1PQ0tTIEZPUiBFWFRFUk5BTCBIVFRQIENBTExTIOKaoO+4jycpO1xuXG4gICAgd3BDbGllbnQuZGVmYXVsdHMuYWRhcHRlciA9IGFzeW5jIChjb25maWcpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGNvbmZpZy51cmwgfHwgJyc7XG4gICAgICAgICAgICBsZXQgbW9ja0ZpbGUgPSAnJztcblxuICAgICAgICAgICAgLy8gR2VuZXJpYyBSb3V0ZXJcbiAgICAgICAgICAgIC8vIEltcHJvdmVkIFJlZ2V4IHRvIGhhbmRsZSBuZXN0ZWQgcmVzb3VyY2VzIGxpa2UgJ3Byb2R1Y3RzL2NhdGVnb3JpZXMnIG9yICdyZXBvcnRzL3NhbGVzJy5cbiAgICAgICAgICAgIC8vIFN0cmF0ZWd5OiBDaGVjayBzcGVjaWZpY2FsbHkgZm9yIGtub3duIG5lc3RlZCBwYXR0ZXJucyBmaXJzdCwgb3IgdXNlIGEgbW9yZSBncmVlZHkgbWF0Y2guXG4gICAgICAgICAgICAvLyBCdXQgJ3Byb2R1Y3RzLzEyMycgdnMgJ3Byb2R1Y3RzL2NhdGVnb3JpZXMnIGlzIGFtYmlndW91cyB3aXRob3V0IGtub3dsZWRnZS5cbiAgICAgICAgICAgIC8vIExldCdzIGhhcmRjb2RlIGtub3duIG5lc3RlZCB2YWxpZCBlbmRwb2ludHMgZm9yIHRoaXMgcHJvamVjdCBhcyBleGNlcHRpb25zLCBvciBjaGVjayBkaXJlY3RvcnkgZXhpc3RlbmNlLlxuXG4gICAgICAgICAgICAvLyBTaW1wbGUgYXBwcm9hY2g6IENhcHR1cmUgdXAgdG8gMiBzZWdtZW50cyBhZnRlciB2ZXJzaW9uLlxuICAgICAgICAgICAgY29uc3QgcmVnZXggPSAvXlxcLz8oPzood2MpXFwvdjN8KGxkbG1zKVxcL3YyfCh3cClcXC92MilcXC8oLispLztcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdXJsLm1hdGNoKHJlZ2V4KTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbnMgPSBtYXRjaFsxXSB8fCBtYXRjaFsyXSB8fCBtYXRjaFszXTsgLy8gd2MsIGxkbG1zLCB3cFxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhTdWZmaXggPSBtYXRjaFs0XTsgLy8gZS5nLiBcInByb2R1Y3RzL2NhdGVnb3JpZXNcIiwgXCJwcm9kdWN0cy8xMjNcIiwgXCJvcmRlcnNcIlxuXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBkZWNpZGUgd2hhdCBwYXJ0IGlzICdyZXNvdXJjZScgYW5kIHdoYXQgaXMgJ2lkJy5cbiAgICAgICAgICAgICAgICAvLyBIZXVyaXN0aWM6XG4gICAgICAgICAgICAgICAgLy8gMS4gQ2hlY2sgaWYgZnVsbCBwYXRoIG1hcHMgdG8gYSBkaXJlY3RvcnkgLT4gSXQncyBhIGxpc3QgKHJlc291cmNlPWZ1bGwgcGF0aCkuXG4gICAgICAgICAgICAgICAgLy8gMi4gRWxzZSwgc3BsaXQgbGFzdCBzZWdtZW50IGFzIElELCByZXN0IGFzIHJlc291cmNlLlxuXG4gICAgICAgICAgICAgICAgY29uc3QgZm9sZGVyTnMgPSBucyA9PT0gJ2xkbG1zJyA/ICdsZCcgOiBucztcbiAgICAgICAgICAgICAgICBjb25zdCByb290TW9ja0RpciA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCBgbW9ja3Mvd29yZHByZXNzLyR7Zm9sZGVyTnN9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zc2libGVEaXIgPSBwYXRoLmpvaW4ocm9vdE1vY2tEaXIsIHBhdGhTdWZmaXgpO1xuXG4gICAgICAgICAgICAgICAgbGV0IHJlc291cmNlLCBpZDtcblxuICAgICAgICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKHBvc3NpYmxlRGlyKSAmJiBmcy5sc3RhdFN5bmMocG9zc2libGVEaXIpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSXQgaXMgYSBkaXJlY3RvcnkgKGUuZy4gcHJvZHVjdHMvY2F0ZWdvcmllcywgb3IgcHJvZHVjdHMpXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlID0gcGF0aFN1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEl0IGlzIG5vdCBhIGRpcmVjdG9yeS4gQXNzdW1lIGxhc3QgcGFydCBpcyBJRC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBwYXRoU3VmZml4LnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA9IHBhcnRzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPSBwYXJ0cy5qb2luKCcvJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG91bGQgaGF2ZSBiZWVuIGEgZGlyZWN0b3J5IGlmIGl0IHdhcyBhIGxpc3Qgcm9vdC4uLiBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBtYXliZSBkaXJlY3RvcnkgaXMgbWlzc2luZz9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlID0gcGF0aFN1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VEaXIgPSBwYXRoLmpvaW4ocm9vdE1vY2tEaXIsIHJlc291cmNlKTtcblxuICAgICAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgc3BlY2lmaWMgSURcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BlY2lmaWMgPSBwYXRoLmpvaW4oYmFzZURpciwgYCR7aWR9Lmpzb25gKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmID0gcGF0aC5qb2luKGJhc2VEaXIsICdkZWZhdWx0Lmpzb24nKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhzcGVjaWZpYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vY2tGaWxlID0gc3BlY2lmaWM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZnMuZXhpc3RzU3luYyhkZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2NrRmlsZSA9IGRlZjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrOiBDaGVjayBpZiBsaXN0IGV4aXN0cywgbWF5YmU/IE5vLCB1c3VhbGx5IElEIGNhbGwgZXhwZWN0cyBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiByZWFsbHkgbm90aGluZyBmb3VuZCwgd2UgbGV0IGZhbGwgdGhyb3VnaCB0byA0MDRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExpc3RcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlzdCA9IHBhdGguam9pbihiYXNlRGlyLCAnbGlzdC5qc29uJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGxpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2NrRmlsZSA9IGxpc3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU29tZSBlbmRwb2ludHMgbGlrZSBzaW5nbGV0b25zICh1c2Vycy1jb3Vyc2UtcHJvZ3Jlc3MpIG1pZ2h0IGJlaGF2ZSBsaWtlIFwiZGVmYXVsdFwiIHdpdGhvdXQgSUQ/XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGEgJ2RlZmF1bHQuanNvbicgZm9yIHRoZSByZXNvdXJjZSByb290PyBcbiAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiB1c2Vycy1jb3Vyc2UtcHJvZ3Jlc3NfdjIvZGVmYXVsdC5qc29uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvb3REZWZhdWx0ID0gcGF0aC5qb2luKGJhc2VEaXIsICdkZWZhdWx0Lmpzb24nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtb2NrRmlsZSAmJiBmcy5leGlzdHNTeW5jKHJvb3REZWZhdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9ja0ZpbGUgPSByb290RGVmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtNT0NLXSBVUkwgJHt1cmx9IGRpZCBub3QgbWF0Y2ggc3VwcG9ydGVkIHBhdHRlcm5zLmApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobW9ja0ZpbGUgJiYgZnMuZXhpc3RzU3luYyhtb2NrRmlsZSkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMobW9ja0ZpbGUsICd1dGY4JykpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW01PQ0tdIFNlcnZpbmcgJHttb2NrRmlsZX0gZm9yICR7dXJsfWApO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6ICdPSycsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHsgbWVzc2FnZTogJ0ZhaWxlZCB0byBwYXJzZSBtb2NrIGZpbGUnLCBjb25maWcsIHJlc3BvbnNlOiB7IHN0YXR1czogNTAwIH0gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW01PQ0tdIE5vIG1vY2sgZm91bmQgZm9yICR7dXJsfSwgcmV0dXJuaW5nIDQwNGApO1xuICAgICAgICAgICAgICAgIC8vIFNpbXVsYXRlIDQwNCBmb3IgdW5rbm93biBtb2Nrc1xuICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlIDQwNCcsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBeGlvc0Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogJ0VSUl9CQURfUkVRVUVTVCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogNDA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogJ05vdCBGb3VuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IGNvZGU6ICdyZXN0X25vX3JvdXRlJywgbWVzc2FnZTogJ05vIHJvdXRlIHdhcyBmb3VuZCBtYXRjaGluZyB0aGUgVVJMIGFuZCByZXF1ZXN0IG1ldGhvZCcsIGRhdGE6IHsgc3RhdHVzOiA0MDQgfSB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxuLy8gSGVscGVyIGZvciBCYXNpYyBBdXRoIChXb29Db21tZXJjZSlcbmNvbnN0IGdldFdjQXV0aEhlYWRlciA9ICgpID0+IHtcbiAgICBjb25zdCBhdXRoID0gQnVmZmVyLmZyb20oYCR7Y29uZmlnLndvcmRwcmVzcy53Y0NvbnN1bWVyS2V5fToke2NvbmZpZy53b3JkcHJlc3Mud2NDb25zdW1lclNlY3JldH1gKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgcmV0dXJuIGBCYXNpYyAke2F1dGh9YDtcbn07XG5cbi8vIEhlbHBlciBmb3IgQXBwbGljYXRpb24gUGFzc3dvcmQgKExlYXJuRGFzaClcbmNvbnN0IGdldExkQXV0aEhlYWRlciA9ICgpID0+IHtcbiAgICBjb25zdCBhdXRoID0gQnVmZmVyLmZyb20oYCR7Y29uZmlnLndvcmRwcmVzcy5sZFVzZXJ9OiR7Y29uZmlnLndvcmRwcmVzcy5sZEFwcFBhc3N3b3JkfWApLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICByZXR1cm4gYEJhc2ljICR7YXV0aH1gO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgd3BDbGllbnQsXG4gICAgZ2V0V2NBdXRoSGVhZGVyLFxuICAgIGdldExkQXV0aEhlYWRlclxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTUEsS0FBSyxHQUFHQyxPQUFPLENBQUMsT0FBTyxDQUFDO0FBQzlCLE1BQU1DLElBQUksR0FBR0QsT0FBTyxDQUFDLE1BQU0sQ0FBQztBQUM1QixNQUFNRSxLQUFLLEdBQUdGLE9BQU8sQ0FBQyxPQUFPLENBQUM7QUFDOUIsTUFBTUcsTUFBTSxHQUFHSCxPQUFPLENBQUMsV0FBVyxDQUFDO0FBRW5DLE1BQU1JLFNBQVMsR0FBRyxJQUFJSCxJQUFJLENBQUNJLEtBQUssQ0FBQztFQUFFQyxTQUFTLEVBQUU7QUFBSyxDQUFDLENBQUM7QUFDckQsTUFBTUMsVUFBVSxHQUFHLElBQUlMLEtBQUssQ0FBQ0csS0FBSyxDQUFDO0VBQUVDLFNBQVMsRUFBRTtBQUFLLENBQUMsQ0FBQztBQUV2RCxNQUFNRSxRQUFRLEdBQUdULEtBQUssQ0FBQ1UsTUFBTSxDQUFDO0VBQzFCQyxPQUFPLEVBQUVQLE1BQU0sQ0FBQ1EsU0FBUyxDQUFDQyxHQUFHO0VBQzdCQyxPQUFPLEVBQUUsS0FBSztFQUFFO0VBQ2hCVCxTQUFTO0VBQ1RHLFVBQVU7RUFDVk8sT0FBTyxFQUFFO0lBQ0wsY0FBYyxFQUFFO0VBQ3BCO0FBQ0osQ0FBQyxDQUFDOztBQUVGO0FBQ0EsSUFBSUMsT0FBTyxDQUFDQyxHQUFHLENBQUNDLFNBQVMsS0FBSyxNQUFNLEVBQUU7RUFDbEMsTUFBTUMsRUFBRSxHQUFHbEIsT0FBTyxDQUFDLElB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