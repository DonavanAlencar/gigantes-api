7799185975f420f276b00808767d4af1
const cache = require('./cache');
const {
  wpClient,
  getWcAuthHeader,
  getLdAuthHeader
} = require('./http');
const config = require('../config');
const CACHE_TTL = 3600; // 1 hour

const getProduct = async id => {
  const cacheKey = `sistemagigantes:bff:product:${id}`;
  const redis = cache.getClient();

  // Cache Aside
  const cached = await redis.get(cacheKey);
  if (cached) {
    return JSON.parse(cached);
  }
  try {
    // Fetch Product from WooCommerce
    const wcRes = await wpClient.get(`/wc/v3/products/${id}`, {
      headers: {
        Authorization: getWcAuthHeader()
      }
    });
    const product = wcRes.data;

    // Extract Related Courses (using metadata)
    // According to report: meta_key: '_related_course'
    // meta_value: "a:4:{i:0;i:2553;i:1;i:2327;i:2;i:2324;i:3;i:1836;}" (PHP Serialized)
    // We might not be able to easily deserialize PHP in JS without a library.
    // Alternative: If LearnDash/WC exposes this in a better way.
    // Or we use a regex or a simple parser if it's just an array of IDs.

    let relatedCourses = [];
    const relatedCourseMeta = product.meta_data.find(m => m.key === '_related_course');
    if (relatedCourseMeta && typeof relatedCourseMeta.value === 'string') {
      // Simple regex to extract integers from the serialized string
      // Matches i:<integer>; or s:<length>:"<value>"; (but here we expect IDs)
      // Example: i:2553;
      const matches = relatedCourseMeta.value.match(/i:(\d+);/g);
      if (matches) {
        // PHP Serialized array: i:0;i:2553;i:1;i:2327;
        // Matches will be: ["i:0;", "i:2553;", "i:1;", "i:2327;"]
        // We want the values (odd indices), not the keys (even indices).
        const allInts = matches.map(m => parseInt(m.match(/i:(\d+);/)[1]));
        relatedCourses = allInts.filter((_, index) => index % 2 !== 0);
      }
    } else if (relatedCourseMeta && Array.isArray(relatedCourseMeta.value)) {
      // Sometimes API returns it deserialized (less likely for this plugin)
      relatedCourses = relatedCourseMeta.value;
    }

    // Fetch Courses Details (Optimized: Parallel or Single call if supported)
    // LD API: /ldlms/v2/sfwd-courses/<id>
    // Use Promise.all
    const courses = await Promise.all(relatedCourses.map(async courseId => {
      try {
        // Check cache for individual course first? 
        // Report says: sistemagigantes:bff:product:{id} caches everything.
        // We'll just fetch.
        const courseRes = await wpClient.get(`/ldlms/v2/sfwd-courses/${courseId}`, {
          headers: {
            Authorization: getLdAuthHeader()
          }
        });
        return {
          id: courseRes.data.id,
          title: courseRes.data.title && courseRes.data.title.rendered,
          link: courseRes.data.link
        };
      } catch (err) {
        if (err.response && err.response.status === 404) {
          return {
            id: courseId,
            error: 'Course not found (404)'
          };
        }
        console.error(`Failed to fetch course ${courseId}:`, err.message);
        return {
          id: courseId,
          error: err.message || 'Failed to load course data'
        };
      }
    }));
    const response = {
      id: product.id,
      name: product.name,
      slug: product.slug,
      price: product.price,
      status: product.status,
      related_courses: courses
    };

    // Save to Redis
    await redis.set(cacheKey, JSON.stringify(response), 'EX', CACHE_TTL);
    return response;
  } catch (error) {
    if (error.response && error.response.status === 404) {
      throw new Error('Product not found');
    }
    throw error;
  }
};
module.exports = {
  getProduct
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjYWNoZSIsInJlcXVpcmUiLCJ3cENsaWVudCIsImdldFdjQXV0aEhlYWRlciIsImdldExkQXV0aEhlYWRlciIsImNvbmZpZyIsIkNBQ0hFX1RUTCIsImdldFByb2R1Y3QiLCJpZCIsImNhY2hlS2V5IiwicmVkaXMiLCJnZXRDbGllbnQiLCJjYWNoZWQiLCJnZXQiLCJKU09OIiwicGFyc2UiLCJ3Y1JlcyIsImhlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwicHJvZHVjdCIsImRhdGEiLCJyZWxhdGVkQ291cnNlcyIsInJlbGF0ZWRDb3Vyc2VNZXRhIiwibWV0YV9kYXRhIiwiZmluZCIsIm0iLCJrZXkiLCJ2YWx1ZSIsIm1hdGNoZXMiLCJtYXRjaCIsImFsbEludHMiLCJtYXAiLCJwYXJzZUludCIsImZpbHRlciIsIl8iLCJpbmRleCIsIkFycmF5IiwiaXNBcnJheSIsImNvdXJzZXMiLCJQcm9taXNlIiwiYWxsIiwiY291cnNlSWQiLCJjb3Vyc2VSZXMiLCJ0aXRsZSIsInJlbmRlcmVkIiwibGluayIsImVyciIsInJlc3BvbnNlIiwic3RhdHVzIiwiZXJyb3IiLCJjb25zb2xlIiwibWVzc2FnZSIsIm5hbWUiLCJzbHVnIiwicHJpY2UiLCJyZWxhdGVkX2NvdXJzZXMiLCJzZXQiLCJzdHJpbmdpZnkiLCJFcnJvciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlcyI6WyJwcm9kdWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNhY2hlID0gcmVxdWlyZSgnLi9jYWNoZScpO1xuY29uc3QgeyB3cENsaWVudCwgZ2V0V2NBdXRoSGVhZGVyLCBnZXRMZEF1dGhIZWFkZXIgfSA9IHJlcXVpcmUoJy4vaHR0cCcpO1xuY29uc3QgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG5cbmNvbnN0IENBQ0hFX1RUTCA9IDM2MDA7IC8vIDEgaG91clxuXG5jb25zdCBnZXRQcm9kdWN0ID0gYXN5bmMgKGlkKSA9PiB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBgc2lzdGVtYWdpZ2FudGVzOmJmZjpwcm9kdWN0OiR7aWR9YDtcbiAgICBjb25zdCByZWRpcyA9IGNhY2hlLmdldENsaWVudCgpO1xuXG4gICAgLy8gQ2FjaGUgQXNpZGVcbiAgICBjb25zdCBjYWNoZWQgPSBhd2FpdCByZWRpcy5nZXQoY2FjaGVLZXkpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoY2FjaGVkKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICAvLyBGZXRjaCBQcm9kdWN0IGZyb20gV29vQ29tbWVyY2VcbiAgICAgICAgY29uc3Qgd2NSZXMgPSBhd2FpdCB3cENsaWVudC5nZXQoYC93Yy92My9wcm9kdWN0cy8ke2lkfWAsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBnZXRXY0F1dGhIZWFkZXIoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJvZHVjdCA9IHdjUmVzLmRhdGE7XG5cbiAgICAgICAgLy8gRXh0cmFjdCBSZWxhdGVkIENvdXJzZXMgKHVzaW5nIG1ldGFkYXRhKVxuICAgICAgICAvLyBBY2NvcmRpbmcgdG8gcmVwb3J0OiBtZXRhX2tleTogJ19yZWxhdGVkX2NvdXJzZSdcbiAgICAgICAgLy8gbWV0YV92YWx1ZTogXCJhOjQ6e2k6MDtpOjI1NTM7aToxO2k6MjMyNztpOjI7aToyMzI0O2k6MztpOjE4MzY7fVwiIChQSFAgU2VyaWFsaXplZClcbiAgICAgICAgLy8gV2UgbWlnaHQgbm90IGJlIGFibGUgdG8gZWFzaWx5IGRlc2VyaWFsaXplIFBIUCBpbiBKUyB3aXRob3V0IGEgbGlicmFyeS5cbiAgICAgICAgLy8gQWx0ZXJuYXRpdmU6IElmIExlYXJuRGFzaC9XQyBleHBvc2VzIHRoaXMgaW4gYSBiZXR0ZXIgd2F5LlxuICAgICAgICAvLyBPciB3ZSB1c2UgYSByZWdleCBvciBhIHNpbXBsZSBwYXJzZXIgaWYgaXQncyBqdXN0IGFuIGFycmF5IG9mIElEcy5cblxuICAgICAgICBsZXQgcmVsYXRlZENvdXJzZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVsYXRlZENvdXJzZU1ldGEgPSBwcm9kdWN0Lm1ldGFfZGF0YS5maW5kKG0gPT4gbS5rZXkgPT09ICdfcmVsYXRlZF9jb3Vyc2UnKTtcblxuICAgICAgICBpZiAocmVsYXRlZENvdXJzZU1ldGEgJiYgdHlwZW9mIHJlbGF0ZWRDb3Vyc2VNZXRhLnZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gU2ltcGxlIHJlZ2V4IHRvIGV4dHJhY3QgaW50ZWdlcnMgZnJvbSB0aGUgc2VyaWFsaXplZCBzdHJpbmdcbiAgICAgICAgICAgIC8vIE1hdGNoZXMgaTo8aW50ZWdlcj47IG9yIHM6PGxlbmd0aD46XCI8dmFsdWU+XCI7IChidXQgaGVyZSB3ZSBleHBlY3QgSURzKVxuICAgICAgICAgICAgLy8gRXhhbXBsZTogaToyNTUzO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHJlbGF0ZWRDb3Vyc2VNZXRhLnZhbHVlLm1hdGNoKC9pOihcXGQrKTsvZyk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIC8vIFBIUCBTZXJpYWxpemVkIGFycmF5OiBpOjA7aToyNTUzO2k6MTtpOjIzMjc7XG4gICAgICAgICAgICAgICAgLy8gTWF0Y2hlcyB3aWxsIGJlOiBbXCJpOjA7XCIsIFwiaToyNTUzO1wiLCBcImk6MTtcIiwgXCJpOjIzMjc7XCJdXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0aGUgdmFsdWVzIChvZGQgaW5kaWNlcyksIG5vdCB0aGUga2V5cyAoZXZlbiBpbmRpY2VzKS5cbiAgICAgICAgICAgICAgICBjb25zdCBhbGxJbnRzID0gbWF0Y2hlcy5tYXAobSA9PiBwYXJzZUludChtLm1hdGNoKC9pOihcXGQrKTsvKVsxXSkpO1xuICAgICAgICAgICAgICAgIHJlbGF0ZWRDb3Vyc2VzID0gYWxsSW50cy5maWx0ZXIoKF8sIGluZGV4KSA9PiBpbmRleCAlIDIgIT09IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlbGF0ZWRDb3Vyc2VNZXRhICYmIEFycmF5LmlzQXJyYXkocmVsYXRlZENvdXJzZU1ldGEudmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBTb21ldGltZXMgQVBJIHJldHVybnMgaXQgZGVzZXJpYWxpemVkIChsZXNzIGxpa2VseSBmb3IgdGhpcyBwbHVnaW4pXG4gICAgICAgICAgICByZWxhdGVkQ291cnNlcyA9IHJlbGF0ZWRDb3Vyc2VNZXRhLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmV0Y2ggQ291cnNlcyBEZXRhaWxzIChPcHRpbWl6ZWQ6IFBhcmFsbGVsIG9yIFNpbmdsZSBjYWxsIGlmIHN1cHBvcnRlZClcbiAgICAgICAgLy8gTEQgQVBJOiAvbGRsbXMvdjIvc2Z3ZC1jb3Vyc2VzLzxpZD5cbiAgICAgICAgLy8gVXNlIFByb21pc2UuYWxsXG4gICAgICAgIGNvbnN0IGNvdXJzZXMgPSBhd2FpdCBQcm9taXNlLmFsbChyZWxhdGVkQ291cnNlcy5tYXAoYXN5bmMgKGNvdXJzZUlkKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGNhY2hlIGZvciBpbmRpdmlkdWFsIGNvdXJzZSBmaXJzdD8gXG4gICAgICAgICAgICAgICAgLy8gUmVwb3J0IHNheXM6IHNpc3RlbWFnaWdhbnRlczpiZmY6cHJvZHVjdDp7aWR9IGNhY2hlcyBldmVyeXRoaW5nLlxuICAgICAgICAgICAgICAgIC8vIFdlJ2xsIGp1c3QgZmV0Y2guXG4gICAgICAgICAgICAgICAgY29uc3QgY291cnNlUmVzID0gYXdhaXQgd3BDbGllbnQuZ2V0KGAvbGRsbXMvdjIvc2Z3ZC1jb3Vyc2VzLyR7Y291cnNlSWR9YCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBnZXRMZEF1dGhIZWFkZXIoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGNvdXJzZVJlcy5kYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogY291cnNlUmVzLmRhdGEudGl0bGUgJiYgY291cnNlUmVzLmRhdGEudGl0bGUucmVuZGVyZWQsXG4gICAgICAgICAgICAgICAgICAgIGxpbms6IGNvdXJzZVJlcy5kYXRhLmxpbmtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5yZXNwb25zZSAmJiBlcnIucmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaWQ6IGNvdXJzZUlkLCBlcnJvcjogJ0NvdXJzZSBub3QgZm91bmQgKDQwNCknIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBmZXRjaCBjb3Vyc2UgJHtjb3Vyc2VJZH06YCwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGlkOiBjb3Vyc2VJZCwgZXJyb3I6IGVyci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gbG9hZCBjb3Vyc2UgZGF0YScgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgaWQ6IHByb2R1Y3QuaWQsXG4gICAgICAgICAgICBuYW1lOiBwcm9kdWN0Lm5hbWUsXG4gICAgICAgICAgICBzbHVnOiBwcm9kdWN0LnNsdWcsXG4gICAgICAgICAgICBwcmljZTogcHJvZHVjdC5wcmljZSxcbiAgICAgICAgICAgIHN0YXR1czogcHJvZHVjdC5zdGF0dXMsXG4gICAgICAgICAgICByZWxhdGVkX2NvdXJzZXM6IGNvdXJzZXNcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTYXZlIHRvIFJlZGlzXG4gICAgICAgIGF3YWl0IHJlZGlzLnNldChjYWNoZUtleSwgSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UpLCAnRVgnLCBDQUNIRV9UVEwpO1xuXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvci5yZXNwb25zZSAmJiBlcnJvci5yZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9kdWN0IG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdldFByb2R1Y3Rcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLEtBQUssR0FBR0MsT0FBTyxDQUFDLFNBQVMsQ0FBQztBQUNoQyxNQUFNO0VBQUVDLFFBQVE7RUFBRUMsZUFBZTtFQUFFQztBQUFnQixDQUFDLEdBQUdILE9BQU8sQ0FBQyxRQUFRLENBQUM7QUFDeEUsTUFBTUksTUFBTSxHQUFHSixPQUFPLENBQUMsV0FBVyxDQUFDO0FBRW5DLE1BQU1LLFNBQVMsR0FBRyxJQUFJLENBQUMsQ0FBQzs7QUFFeEIsTUFBTUMsVUFBVSxHQUFHLE1BQU9DLEVBQUUsSUFBSztFQUM3QixNQUFNQyxRQUFRLEdBQUcsK0JBQStCRCxFQUFFLEVBQUU7RUFDcEQsTUFBTUUsS0FBSyxHQUFHVixLQUFLLENBQUNXLFNBQVMsQ0FBQyxDQUFDOztFQUUvQjtFQUNBLE1BQU1DLE1BQU0sR0FBRyxNQUFNRixLQUFLLENBQUNHLEdBQUcsQ0FBQ0osUUFBUSxDQUFDO0VBQ3hDLElBQUlHLE1BQU0sRUFBRTtJQUNSLE9BQU9FLElBQUksQ0FBQ0MsS0FBSyxDQUFDSCxNQUFNLENBQUM7RUFDN0I7RUFFQSxJQUFJO0lBQ0E7SUFDQSxNQUFNSSxLQUFLLEdBQUcsTUFB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